
EID_OK = 0

{{ runner['code']['strategy_class'] }}

class EAStrategyRunner:
    def __init__(self):
        self.runner_status_cache_name = f"__runner_status__"
        self.default_process = {
            'run_processes': {
                'process_orders': {'func': self.process_orders},
                'open_orders': {'func': self.open_orders},
            },
            'open_processes': {
            },
            'order_processes': {
                'stop_by_time': {'func': self.process_order_stop_by_time},
            }
        }


    def init_data(self, *args, **kwargs):
        return True

    def debug_print(self, message, add_info=True, notify=False):
        if not self.options.get('debug_print', False):
            return
        if add_info:
            msg = f"[{Symbol()}]({str(Time()), Open(), Low(), High(), Close(), Ask(), Bid()}) {message}"
        else:
            msg = message
        print(msg)
        if self.options.get('enable_notify', False) and notify:
            Notify(msg)

    def usdpip(self):
        currency_profit = SymbolInfo("currency_profit")
        currency_base = SymbolInfo("currency_base")
        pd = self.pip_digits()
        if currency_profit == "USD":
            return math.pow(10, pd*-1)
        elif currency_base == 'USD':
            return math.pow(10, pd*-1) / Close()
        return None

    def calculate_size(self, open_price, close_price, max_sl_amount):
        return self.money_to_lots(max_sl_amount, self.points_to_pips(abs(close_price - open_price)))

    def lots_to_money(self, lots, pips):
        usd_pip = self.usdpip()
        if usd_pip is None or usd_pip == 0:
            return 0.0
        money = lots * (usd_pip * pips * SymbolInfo("trade_contract_size"))
        if isnull(money):
            return 0.0
        return money

    def money_to_lots(self, money, pips):
        usd_pip = self.usdpip()
        if usd_pip is None or usd_pip == 0:
            return 0.0
        lots = money / (usd_pip * pips * SymbolInfo("trade_contract_size"))
        if isnull(lots):
            return 0.0
        minLot = SymbolInfo("volume_min")
        ret = int((lots+minLot) / minLot) * minLot
        return ret

    def money_to_pips(self, money, volume):
        usd_pip = self.usdpip()
        if usd_pip is None or usd_pip == 0 or volume <= 0 or money <= 0:
            return 0.0
        profit_pips = money / (volume * usd_pip * SymbolInfo("trade_contract_size"))
        return profit_pips

    def money_to_points(self, money, volume):
        profit_pips = self.money_to_pips(money, volume)
        points = self.pips_to_points(profit_pips)
        return points

    def get_free_margin(self, params):
        account = GetAccount()

        account_free_margin = account.equity
        margin_leverage = params.get('margin_leverage', 1)
        max_margin = params.get('max_margin', 0)
        if margin_leverage > 1:
            account_free_margin = account_free_margin * margin_leverage

        if max_margin <= 0 or account_free_margin < max_margin:
            return account_free_margin
        else:
            return max_margin

    def max_sl_amount_per_order(self, params):
        max_sl_percent = params['max_sl_percent']
        ret = self.get_free_margin(params) * max_sl_percent
        return ret

    def pips_to_points(self, pips):
        digits = SymbolInfo("digits")
        point = SymbolInfo("point")
        if digits % 2 == 1:
            pips2dbl = point * 10
            pips2points = 10
            digits_pips = 1
        else:
            pips2dbl = point
            pips2points = 1
            digits_pips = 0
        return pips * pips2dbl

    def pip_digits(self):
        digits = SymbolInfo("digits")
        if digits % 2 == 1:
            return digits - 1
        else:
            return digits

    def points_to_pips(self, value_point):
        if isnull(value_point):
            return nan
        digits = SymbolInfo("digits")
        point = SymbolInfo("point")
        if digits % 2 == 1:
            pips2dbl = point * 10
        else:
            pips2dbl = point
        return float(value_point / pips2dbl)

    def close_order(self, order, tag):
        errid, result = CloseOrder(order.uid)

    def open_orders(self, params):
        pn = 'open_processes'
        op_list = self.options[pn]
        new_order_list = []
        for op in op_list:
            func = op.get('func', self.default_process[pn].get(op['name'], {'func': None})['func'])
            if func is None:
                self.debug_print(f"Func {op['name']} is None!")
                return -2, None
            using_order_list = op.get('order_list', False)
            if using_order_list:
                if not func(new_order_list, op):
                    return -1, None
            else:
                for no in new_order_list:
                    if no['errid'] != 0:
                        continue
                    if not func(no, op):
                        no['errid'] = -1

        ret = []
        for new_order in new_order_list:
            errid = new_order['errid']
            rv = dict(order=new_order, errid=errid)
            ret.append(rv)
            if errid != 0:
                continue
            position = new_order['position']
            order_type = new_order.get('order_type', OrderType.MARKET)
            size = new_order['size']
            price = new_order['price']
            slippage = new_order.get('slippage', 10)
            stop_loss = new_order.get('stop_loss', None)
            take_profit = new_order.get('take_profit', None)
            tags = new_order.get('tags', None)
            if position == PositionType.LONG:
                errid, result = Buy(size, type=order_type, price=price, slippage=slippage, stop_loss=stop_loss, take_profit=take_profit,
                                    tags=tags)
                self.debug_print(f"Buy: {errid}, {result}")
            elif position == PositionType.SHORT:
                errid, result = Sell(size, type=order_type, price=price, slippage=slippage, stop_loss=stop_loss, take_profit=take_profit,
                                     tags=tags)
                self.debug_print(f"Sell: {errid}, {result}")
            else:
                rv['errid'] = -3
                continue
            rv['errid'] = errid
            rv['result'] = result

        return 0, ret

    def process_order_stop_by_time(self, order, params):
        if order is None:
            return False
        if order.symbol != Symbol():
            return False
        total_seconds = (Time() - order.open_time).total_seconds()
        c_timeout = params['c_timeout']
        if total_seconds < c_timeout:
            return False
        max_order_time = params.get('max_order_time', 0)
        if 0 < max_order_time <= total_seconds:
            self.close_order(order, 'max_order_time')
            return True
        sl_ratio = (total_seconds - c_timeout) / MAX_ORDER_TIME
        max_points = self.points_to_pips(abs(order.stop_loss - order.open_price))
        cur_points = self.points_to_pips(abs(Close() - order.open_price))
        if cur_points > max_points * sl_ratio:
            return False
        self.debug_print(f"close: {Time(0)},{Time(1)}, minute={int(total_seconds/60)}, order.profit={order.profit}, max_points={max_points}, cur_points={cur_points}, sl_p={max_points * sl_ratio}, sl_ratio={sl_ratio}")
        self.close_order(order, 'timeout')
        return True

    def process_order(self, o):
        pn = 'order_processes'
        op_list = self.options[pn]
        for op in op_list:
            func = op.get('func', self.default_process[pn].get(op['name'], {'func': None})['func'])
            if func is None:
                self.debug_print(f"Func {op['name']} is None!")
                return False
            if func(o, op):
                return True
        return False

    def process_orders(self, params):
        order_dict = GetOpenedOrderUIDs()
        for order_uid in order_dict:
            o = GetOrder(order_uid)
            if o is not None:
                self.process_order(o)
            else:
                self.debug_print(f"ERROR: {order_uid} is None")

    def run(self):
        if not self.init_data():
            self.debug_print(f"init_data error, exit ...!")
            return -1
        pn = 'run_processes'
        op_list = self.options.get(pn, [dict(name='process_orders'), dict(name='open_orders'), ])
        for op in op_list:
            func = op.get('func', self.default_process[pn].get(op['name'], {'func': None})['func'])
            if func is None:
                self.debug_print(f"Func {op['name']} is None!")
                return -2
            func(op)
        return 0

    def load_status_data(self, status, default=None):
        data = LoadData(scope=DataScope.EA_SETTIGNS, name=self.runner_status_cache_name)
        if data is None:
            data = {}
        return data.get(status, default)

    def save_status_data(self, status, value):
        data = LoadData(scope=DataScope.EA_SETTIGNS, name=self.runner_status_cache_name)
        if data is None:
            data = {}
        current_time = Time()
        data[status] = dict(time_ts=current_time.timestamp(), value=value)
        return SaveData(scope=DataScope.EA_SETTIGNS, name=self.runner_status_cache_name, data=data)

    def delete_status_data(self, status):
        data = LoadData(scope=DataScope.EA_SETTIGNS, name=self.runner_status_cache_name)
        if data is None:
            return False
        if status not in data:
            return False
        data.pop(status, None)
        return SaveData(scope=DataScope.EA_SETTIGNS, name=self.runner_status_cache_name, data=data)

# --------------
# main
# --------------
runner = EAStrategyRunner()
strategy = {{runner['strategy_class_name']}}(runner)

run_processes = [
    {'name': 'process_orders', 'func': strategy.process_orders},
    {'name': 'open_orders'},
]
open_processes = [
    {'name': 'open_new', 'func': strategy.open_new, 'order_list': True},
    {'name': 'open_check_trading_time', 'func': strategy.open_check_trading_time},
]
order_processes = [
]
runner.options = {
    'run_processes': run_processes, 'open_processes': open_processes, 'order_processes': order_processes,
    'debug_print': DEBUG_PRINT
}

runner.run()
