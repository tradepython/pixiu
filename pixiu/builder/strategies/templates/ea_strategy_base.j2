{% if render == 'helper' %}
def parse_order_config2(order_config):
    print(order_config)
parse_order_config("aaaa")
{% else %}

OD_LONG_SHORT = 0
OD_LONG_ONLY = 1
OD_SHORT_ONLY = 2
OD_DISABLE = 3

{%  for code in strategy['code']['variables']  -%}
    {{ code }}
{% endfor %}

def valid_source(source):
    valid_source = ('balance', )
    return source in valid_source

def p2f(x, failed_value=None):
    try:
        source = None
        if isinstance(x, str) and len(x) > 1:
            s = x.strip(' ')
            if s[-1:] == '%':
                return float(x.rstrip('%')) / 100, 'percent', source
            else:
                ary = s.split(':')
                if len(ary) == 2:
                    if ary[0][-1:] == '%':
                        source = ary[1].lower()
                        return float(ary[0].rstrip('%')) / 100, 'percent', source
    except:
        pass
    return failed_value, None, None

def to_float(x, failed_value=None):
    ret = failed_value
    ret_type = None
    ret_source = None
    try:
        if isinstance(x, float):
            ret = x
            ret_type = 'float'
        elif isinstance(x, int):
            ret = x
            ret_type = 'int'
        else:
            ret, ret_type, ret_source = p2f(x)
            if ret is None:
                ret = float(x)
                ret_type = 'float'
    except:
        pass
    return ret, ret_type, ret_source

def load_json_value(value, default=None):
    ret = default
    try:
        ret = json.loads(value)
    except:
        pass
    return ret

def valid_order_config_tp_sl(dir, is_tp, conf, tp_type, sl_type, order_volume):
    conf_name = 'take profit' if is_tp else 'stop loss'
    conf_type = tp_type if is_tp else sl_type
    neg_or_pos = 'positive' if is_tp else 'negative'
    sign = 1 if is_tp else -1
    check_order_volume = False

    if conf:
        errmsg = f'Invalid {conf_name} of {dir} order !'
        try:
            conf_type = conf.get('type', None)
            if conf_type is None or conf_type not in ('pips', 'money', 'percent', 'pl-ratio'):
                errmsg = f'Invalid {conf_name} type of {dir} order !'
                return False, errmsg
            if conf_type == 'pips':
                pips = int(conf.get('pips', 0))
                if pips <= 0:
                    errmsg = f'Invalid {conf_name} pips of {dir} order (must be {neg_or_pos}) !'
                    return False, errmsg
            elif conf_type == 'money':
                money = float(conf.get('money', 0))
                if money * sign <= 0:
                    errmsg = f'Invalid {conf_name} money of {dir} order (must be {neg_or_pos}) !'
                    return False, errmsg
                check_order_volume = True
            elif conf_type == 'percent':
                percent = conf.get('percent', None)
                v, rt, rs = to_float(percent)
                if v is None or v * sign <= 0:
                    errmsg = f'Invalid {conf_name} percent of {dir} order (must be {neg_or_pos}) !'
                    return False, errmsg
                source = conf.get('source', 'balance')
                if source:
                    if source not in ('balance', 'atr'):
                        errmsg = f'Invalid {conf_name} source of {dir} order !'
                        return False, errmsg
                    if source in ('atr', ):
                        period = conf.get('period', 0)
                        if period <= 0:
                            errmsg = f'Invalid {conf_name} atr period of {dir} order !'
                            return False, errmsg
                        timeframe = conf.get('timeframe', None)
                        if timeframe is None:
                            errmsg = f'Invalid {conf_name} atr timeframe of {dir} order !'
                            return False, errmsg
                        shift = conf.get('shift', 0)
                        if shift < 0:
                            errmsg = f'Invalid {conf_name} atr shift of {dir} order !'
                            return False, errmsg
                    else:
                        check_order_volume = True
            elif conf_type == 'pl-ratio':
                ratio = float(conf.get('ratio', 0))
                if ratio <= 0:
                    errmsg = f'Invalid profit loss ratio of {dir} order (must be positive) !'
                    return False, errmsg
            else:
                errmsg = f'Unknown {conf_name} type of {dir} order !'
                return False, errmsg

            if tp_type == 'pl-ratio' and sl_type == 'pl-ratio':
                errmsg = f'The stop loss and take profit types of {dir} order cannot be \'pl-ratio\' at the same time !'
                return False, errmsg

            if check_order_volume and order_volume <= 0:
                errmsg = f'Invalid positions volume of {dir} order (must be positive) !'
                return False, errmsg

        except:
            return False, errmsg
    return True, ''

def valid_order_config(dir, order_config):
    tp_type = None
    sl_type = None
    pos_conf = order_config.get('positions', None)
    tp_conf = order_config.get('take_profit', None)
    sl_conf = order_config.get('stop_loss', None)
    if pos_conf is None:
        errmsg = 'Positions of {dir} order is None !'
        return False, errmsg

    order_volume = 0
    errmsg = f'Invalid positions of {dir} order !'
    try:
        pos_type = pos_conf.get('type', None)
        if pos_type is None or pos_type not in ('volume', 'money', 'percent'):
            errmsg = f'Invalid positions type of {dir} order !'
            return False, errmsg
        pos_martingale = pos_conf.get('martingale', None)
        if pos_martingale is not None:
            if isinstance(pos_martingale, bool):
                pass
            elif isinstance(pos_martingale, dict):
                multiplier = pos_martingale.get('multiplier', 0)
                if multiplier < 0:
                    errmsg = f'Invalid positions martingale multiplier of {dir} order (must be positive) !'
                    return False, errmsg
            else:
                errmsg = f'Invalid positions martingale of {dir} order !'
                return False, errmsg

        if pos_type == 'volume':
            order_volume = float(pos_conf.get('volume', 0))
            if order_volume <= 0:
                errmsg = f'Invalid positions volume of {dir} order (must be positive) !'
                return False, errmsg
        elif pos_type == 'money':
            order_money = float(pos_conf.get('money', 0))
            if order_money == 0:
                errmsg = f'Invalid positions money of {dir} order (must not be zero) !'
                return False, errmsg
        elif pos_type == 'percent':
            order_percent = pos_conf.get('percent', None)
            v, rt, rs = to_float(order_percent)
            if v == 0:
                errmsg = f'Invalid positions percent of {dir} order (must not be zero) !'
                return False, errmsg
            order_percent_source = pos_conf.get('source', 'balance')
            if order_percent_source != 'balance':
                errmsg = f'Invalid positions source of {dir} order (must be balance) !'
                return False, errmsg
    except:
        return False, errmsg

    if tp_conf:
        tp_type = tp_conf.get('type', None)

    if sl_conf:
        sl_type = sl_conf.get('type', None)

    ret, errmsg  = valid_order_config_tp_sl(dir, True, tp_conf, tp_type, sl_type, order_volume)
    if not ret:
        return ret, errmsg

    ret, errmsg  = valid_order_config_tp_sl(dir, False, sl_conf, tp_type, sl_type, order_volume)
    if not ret:
        return ret, errmsg

    return True, ''

def PX_ValidScriptSettings(new_settings):
    errmsg = ''
    try:
        if 'params' not in new_settings:
            return dict(success=False, errmsg='Not found params')
        params = new_settings['params']

        risk_day_max_loss = float(params['risk_day_max_loss']['value'])
        if risk_day_max_loss > 0:
            return dict(success=False, errmsg=f"The risk_day_max_loss must be negative.")

        risk_day_max_profit = float(params['risk_day_max_profit']['value'])
        if risk_day_max_profit < 0:
            return dict(success=False, errmsg=f"The risk_day_max_profit must be positive.")

        order_config = dict(
                                positions=load_json_value(ENTRY_LONG_POSITIONS),
                                take_profit=load_json_value(ENTRY_LONG_TAKE_PROFIT),
                                stop_loss=load_json_value(ENTRY_LONG_STOP_LOSS))
        ret, errmsg = valid_order_config('long', order_config)
        if not ret:
            return dict(success=False, errmsg=errmsg)
        order_config = dict(
                                positions=load_json_value(ENTRY_SHORT_POSITIONS),
                                take_profit=load_json_value(ENTRY_SHORT_TAKE_PROFIT),
                                stop_loss=load_json_value(ENTRY_SHORT_STOP_LOSS))
        ret, errmsg = valid_order_config('short', order_config)
        if not ret:
            return dict(success=False, errmsg=errmsg)

        {%  for code in strategy['code'].get('valid_script_settings', [])  -%}
            {{ code }}
        {% endfor %}

        return dict(success=True)
    except Exception as exc:
        errmsg = str(exc)
    return dict(success=False, errmsg=errmsg)

def PX_InitScriptSettings():
    settings = {{strategy['script_settings'] }}
    return settings



class {{ strategy['class_name'] }}:

    def __init__(self, runner):
        self.runner = runner

    def is_night(self, d):
        if d.hour < (8 + TRADING_TIME_ZONE_OFFSET) or d.hour > (19 + TRADING_TIME_ZONE_OFFSET):
            return True
        return False

    def is_weekend(self, d):
        weekday = d.weekday()
        if weekday == 4:
            return True
        return False

    def adjust_price(self, price, opt, digits=None):
        d = None
        if digits is None:
            auto_digits = SymbolInfo("digits")
            if auto_digits % 2 == 1:
                d = auto_digits - 1
        else:
            d = digits
        if opt == 'trunc':
            ret = price
            if d is not None:
                ret = int(price * 10**d) / 10.0**d
            return ret
        elif opt == 'round':
            ret = price
            if d is not None:
                ret = round(price, d)
            return ret
        elif opt == 'ceil':
            ret = price
            if d is not None:
                ret = math.ceil(float(price * 10**d)) / 10.0**d
            return ret
        elif opt == 'floor':
            ret = price
            if d is not None:
                ret = math.floor(float(price * 10**d)) / 10.0**d
            return ret
        else:
            return None

    def open_check_trading_time(self, new_order, params):
        reason = ''
        d = Time()
        if not reason and self.is_night(d):
            if not OPTIONS_ENABLE_NIGHT_OPEN:
                reason = f"OPTIONS_ENABLE_NIGHT_OPEN"
            elif not OPTIONS_ENABLE_NIGHT_HOLDING:
                reason = f"OPTIONS_ENABLE_NIGHT_HOLDING"
            elif self.is_weekend(d):
                if not OPTIONS_ENABLE_WEEKEND_HOLDING:
                    reason = f"OPTIONS_ENABLE_WEEKEND_HOLDING"
        if not reason and self.is_weekend(d) and d.hour > (19 + TRADING_TIME_ZONE_OFFSET):
            if not OPTIONS_ENABLE_WEEKEND_HOLDING:
                reason = f"OPTIONS_ENABLE_WEEKEND_HOLDING"
        if reason:
            s = d.strftime("%Y-%m-%d %H:%M:%S %A")
            self.runner.debug_print(f"WARNING: Can't open new order. (Reason: {reason} @ {s})", notify=False)
            return False
        return True

    def get_order_data(self, order_uid):
        order_data_dict = self.load_group_data('order_data', {})
        order_data = order_data_dict.get(order_uid, {})
        return order_data

    def set_order_data(self, order_uid, data):
        order_data_dict = self.load_group_data('order_data', {})
        order_data_dict[order_uid] = data
        self.save_group_data('order_data', order_data_dict)

    def process_order_init(self, order, params):
        if order is None:
            return False
        if order.symbol != Symbol():
            return False
        order_data = self.get_order_data(order.uid)
        if order_data.get('init', dict(checked=False)).get('checked', False):
            return False
        max_sl_pips = params.get('max_sl_pips', None)
        if max_sl_pips is None:
            return False
        group_info = params['group_info']
        max_sl_points = self.runner.pips_to_points(max_sl_pips)
        new_stop_loss = None
        new_take_profit = None
        if order.is_long():
            sl_points = order.open_price - order.stop_loss
            if order.open_price > order.stop_loss > 0 and round(sl_points, MAX_POINTS) > round(max_sl_points, MAX_POINTS):
                new_stop_loss = round(order.open_price - max_sl_points, MAX_POINTS)
        else:
            sl_points = order.stop_loss - order.open_price
            if 0 < order.open_price < order.stop_loss and round(sl_points, MAX_POINTS) > round(max_sl_points, MAX_POINTS):
                new_stop_loss = round(order.open_price + max_sl_points, MAX_POINTS)

        if new_stop_loss is not None or new_take_profit is not None:
            errid, result = ModifyOrder(uid=order.uid, take_profit=new_take_profit, stop_loss=new_stop_loss)
            if errid == EID_OK:
                return True
        else:
            order_data = self.get_order_data(order.uid)
            order_data['init'] = dict(checked=True)
            self.set_order_data(order.uid, order_data)
            return True
        return False

    def process_order_trailing_profit(self, order, params):
        if order is None:
            return False
        if order.symbol != Symbol():
            return False
        if order.take_profit is None:
            return False

        step_pips = 0
        step_percent = params.get('step_percent', 0)
        if step_percent <= 0:
            step_pips = params.get('step_pips', 0)
            if step_pips <= 0:
                step_profit = params.get('step_profit', 0)
                if step_profit > 0:
                    points = self.runner.money_to_points(step_profit, order.volume)
                    step_pips = self.runner.point_to_pips(points)
        else:
            if 99 >= step_percent > 0:
                step_pips = abs(order.take_profit - order.open_price) * step_percent * 0.01
        if step_pips <= 0:
            return False

        start_profit = params.get('start_profit', 0)
        if start_profit <= 0:
            start_pips = params.get('start_pips', step_pips)
        else:
            points = self.runner.money_to_points(start_profit, order.volume)
            start_pips = self.runner.points_to_pips(points)
        group_info = params['group_info']
        target_profit = params['target_profit']
        no_loss_pips = 0
        trailing_profit_start_points = self.runner.pips_to_points(start_pips)
        trailing_profit_points = self.runner.pips_to_points(step_pips)
        new_take_profit = None
        new_stop_loss = None
        order_data_dict = self.load_group_data('order_data', {})
        order_data = order_data_dict.get(order.uid, {})
        current_time = Time()
        current_time_ts = current_time.timestamp()
        current_time_string = str(current_time)

        process = None
        is_long = order.is_long()
        price = Ask() if is_long else Bid()
        current_profit_points = price - order.open_price if is_long else order.open_price - price
        current_profit_pips = self.runner.points_to_pips(current_profit_points)
        sl_is_loss = order.open_price > order.stop_loss if is_long else order.open_price < order.stop_loss
        reason = ''
        save_order_data = False
        order_init = order.tags.get('init', {})
        sl_pips = order_init.get('max_sl_pips', step_pips)
        order_holding_seconds = (current_time - order.open_time).total_seconds()
        order_holding_minutes = order_holding_seconds / 60

        order_stats = order_data.get('stats', dict(profit=dict(high=dict(profit=0, points=0, pips=0, time=None,
                                                                         time_ts=0, price=0),
                                                               low=dict(profit=0, points=0, pips=0, time=None,
                                                                        time_ts=0, price=0))))
        order_data['stats'] = order_stats
        os_profit = order_stats['profit']
        for k in ('high', 'low'):
            osp = os_profit[k]
            save = order.profit > osp['profit'] if k == 'high' else order.profit < osp['profit']
            if save:
                osp['profit'] = order.profit
                osp['price'] = price
                osp['points'] = current_profit_points
                osp['pips'] = current_profit_pips
                osp['time'] = current_time_string
                osp['time_ts'] = current_time_ts
                save_order_data = True
        amount = self.runner.lots_to_money(order.volume, step_pips)
        net_profit = group_info['stats']['net_profit']

        if net_profit >= target_profit + amount:
            trailing_profit_start_points = current_profit_points

        if OPTIONS_ENABLE_TRAILING_PROFIT and current_profit_points >= trailing_profit_start_points:
            new_take_profit = order.take_profit + trailing_profit_points if is_long else order.take_profit - trailing_profit_points
            new_stop_loss = price - trailing_profit_points if is_long else price + trailing_profit_points
            if is_long:
                if new_stop_loss <= order.stop_loss:
                    return False
            else:
                if new_stop_loss >= order.stop_loss:
                    return False
            process = dict(op='modify_order', new_stop_loss=new_stop_loss, new_take_profit=new_take_profit)
            reason = 'PROFIT_TRAILING'
            tp_data = order_data.get('trailing_profit', {})
            tp_data['count'] = tp_data.get('count', 0) + 1
            tp_data_init = tp_data.get('init', None)
            if tp_data_init is None:
                tp_data['init'] = dict(time_ts=current_time_ts, stop_loss=new_stop_loss)
            tp_data['total_trailing_seconds'] = current_time_ts - tp_data['init']['time_ts']
            tp_data['total_trailing_points'] = abs(new_stop_loss - tp_data['init']['stop_loss'])
            tp_data['time_ts'] = current_time_ts
            tp_data['price'] = price
            tp_data['new_stop_loss'] = new_stop_loss
            order_data['trailing_profit'] = tp_data

        if not process:
            tpp = order.take_profit - order.open_price if is_long else order.open_price - order.take_profit
            if tpp <= trailing_profit_start_points:
                points = trailing_profit_start_points + trailing_profit_points
                new_take_profit = order.open_price + points if is_long else order.open_price - points
                new_stop_loss = None
                process = dict(op='modify_order',
                               new_stop_loss=new_stop_loss, new_take_profit=new_take_profit)
                reason = 'UPDATE_TP'

        if not process and no_loss_pips > 0:
            no_loss_pips_points = self.runner.pips_to_points(no_loss_pips)
            points = price - order.open_price if is_long else order.open_price - price
            if points >= no_loss_pips_points * 1.5:
                new_take_profit = None
                new_stop_loss = price - no_loss_pips_points if is_long else price + no_loss_pips_points
                if is_long:
                    if new_stop_loss <= order.stop_loss:
                        return False
                else:
                    if new_stop_loss >= order.stop_loss:
                        return False
                process = dict(op='modify_order',
                               new_stop_loss=new_stop_loss, new_take_profit=new_take_profit)
                reason = 'NO_LOSS'


        ret = False
        if process:
            errid = 1000
            if process['op'] == 'modify_order':
                new_take_profit = process['new_take_profit']
                new_stop_loss = process['new_stop_loss']
                errid, result = ModifyOrder(uid=order.uid, take_profit=new_take_profit, stop_loss=new_stop_loss)
                self.runner.debug_print(f"process_order_trailing_profit: {Time(0)},{Time(1)}, "
                                        f"ModifyOrder, uid={order.uid}, "
                                        f"new_take_profit={new_take_profit}, "
                                        f"new_stop_loss={new_stop_loss}, reason={reason}, errid={errid}, result={result}",
                                        notify=False)
            elif process['op'] == 'close_order':
                volume = process['volume']
                tags = process.get('tags', None)
                errid, result = CloseOrder(order.uid, volume=volume, tags=tags)
                self.runner.debug_print(f"process_order_trailing_profit: {Time(0)},{Time(1)}, "
                                        f"CloseOrder, uid={order.uid}, "
                                        f"volume={volume}, "
                                        f"tags={tags}, reason={reason}, errid={errid}, result={result}",
                                        notify=False)
            if errid == EID_OK:
                ret = True
                save_order_data = True

        if save_order_data:
            order_data_dict[order.uid] = order_data
            self.save_group_data('order_data', order_data_dict)

        return ret


    def load_stats(self, stats_name=None, default_value=None):
        if stats_name:
            stats_name = f"stats_{Symbol()}_{stats_name}"
        else:
            stats_name = f"stats_{Symbol()}"
        stats = self.load_settings_data(stats_name, default_value)
        return stats

    def save_stats(self, stats, stats_name=None):
        if stats_name:
            stats_name = f"stats_{Symbol()}_{stats_name}"
        else:
            stats_name = f"stats_{Symbol()}"
        self.save_settings_data(stats_name, stats)

    def save_group_logs(self, group_info):
        stats = self.load_stats(stats_name=None, default_value=self.generate_stats_data_dict())
        self.group_stats_to_stats_data(group_info, stats)
        self.save_stats(stats)
        self.runner.debug_print(
            f"DEBUG: save_group_logs: stats = {stats}",
            notify=False)
        days_data = self.load_stats(stats_name='days', default_value=dict(data={}))
        date = Time().strftime("%Y-%m-%d")
        date_stats = days_data['data'].get(date, None)
        if date_stats is None:
            max_days = 30
            if len(days_data['data']) >= max_days:
                remove_days = []
                for k in days_data['data']:
                    d = Time().strptime(k, "%Y-%m-%d")
                    if (Time() - d).days > max_days:
                        remove_days.append(k)
                for k in remove_days:
                    days_data['data'].pop(k, None)
            date_stats = self.generate_stats_data_dict()
        self.group_stats_to_stats_data(group_info, date_stats)
        days_data['data'][date] = date_stats
        self.save_stats(days_data, stats_name='days')
        self.runner.debug_print(
            f"DEBUG: save_group_logs: days_data = {days_data}",
            notify=False)
        group_logs_name = f"group_logs_{Symbol()}"
        group_logs = self.load_settings_data(group_logs_name, dict(logs=[]))
        group_logs['logs'].insert(0, group_info)
        max_len = 30
        if len(group_logs['logs']) > max_len:
            group_logs['logs'] = group_logs['logs'][:max_len]
        self.save_settings_data(group_logs_name, group_logs)
        self.runner.debug_print(
            f"DEBUG: save_group_logs: save_settings_data[{group_logs_name}] = {group_logs}",
            notify=False)


    def generate_stats_data_dict(self):
        return dict(total_groups=0, total_orders=0, total_net_profit=0,
                    total_profit=0, total_commission=0, total_swap=0,
                    last_group_end_time_ts=0, last_group_net_profit=0,
                    total_loss=0, sorted_orders=[],
                    total_loss_groups=0, total_win_groups=0,
                    consecutive_counter=0, consecutive_counter_money=0,
                    max_consecutive_losses=0, max_consecutive_losses_money=0,
                    max_consecutive_wins=0, max_consecutive_wins_money=0,
                    group_init_loss=0,
                    )

    def group_stats_to_stats_data(self, group_info, stats):
        gs = group_info['stats']
        this_group_net_profit = gs['profit'] + gs['loss'] + gs['commission'] + gs['swap']
        if this_group_net_profit < 0:
            stats['total_loss_groups'] = stats['total_loss_groups'] + 1
            if stats['last_group_net_profit'] < 0:
                stats['consecutive_counter'] = stats['consecutive_counter'] + 1
                stats['consecutive_counter_money'] = stats['consecutive_counter_money'] + this_group_net_profit
            else:
                if stats['last_group_net_profit'] > 0:
                    if stats['max_consecutive_wins'] < stats['consecutive_counter']:
                        stats['max_consecutive_wins'] = stats['consecutive_counter']
                    if stats['max_consecutive_wins_money'] < stats['consecutive_counter_money']:
                        stats['max_consecutive_wins_money'] = stats['consecutive_counter_money']
                stats['consecutive_counter'] = 1
                stats['consecutive_counter_money'] = this_group_net_profit
        elif this_group_net_profit > 0:
            stats['total_win_groups'] = stats['total_win_groups'] + 1
            if stats['last_group_net_profit'] > 0:
                stats['consecutive_counter'] = stats['consecutive_counter'] + 1
                stats['consecutive_counter_money'] = stats['consecutive_counter_money'] + this_group_net_profit
            else:
                if stats['last_group_net_profit'] < 0:
                    if stats['max_consecutive_losses'] < stats['consecutive_counter']:
                        stats['max_consecutive_losses'] = stats['consecutive_counter']
                    if stats['max_consecutive_losses_money'] > stats['consecutive_counter_money']:
                        stats['max_consecutive_losses_money'] = stats['consecutive_counter_money']
                stats['consecutive_counter'] = 1
                stats['consecutive_counter_money'] = this_group_net_profit
        stats['total_groups'] = stats['total_groups'] + 1
        stats['total_orders'] = stats['total_orders'] + len(group_info['orders'])
        stats['total_profit'] = stats['total_profit'] + gs['profit']
        stats['total_loss'] = stats['total_loss'] + gs['loss']
        stats['total_commission'] = stats['total_commission'] + gs['commission']
        stats['total_swap'] = stats['total_swap'] + gs['swap']
        stats['last_group_net_profit'] = this_group_net_profit
        stats['total_net_profit'] = stats['total_net_profit'] + stats['last_group_net_profit']
        stats['group_init_loss'] = stats['group_init_loss'] + stats['last_group_net_profit']
        if stats['group_init_loss'] > 0:
            stats['group_init_loss'] = 0
        stats['last_group_end_time_ts'] = Time().timestamp()
        for oid in group_info['sorted_orders']:
            if oid not in stats['sorted_orders']:
                stats['sorted_orders'].append(oid)
        max_orders = 128
        if len(stats['sorted_orders']) > max_orders:
            stats['sorted_orders'] = stats['sorted_orders'][max_orders*-1:]

    def load_settings_data(self, name, default=None, timeout=0):
        data = LoadData(scope=DataScope.EA_SETTIGNS, name=name)
        if data is None:
            return default
        value = data['value']
        if timeout > 0:
            current_time = Time()
            data_time = datetime.fromtimestamp(data['time_ts'])
            total_seconds = (current_time - data_time).total_seconds()
            if total_seconds > timeout:
                return default
        return value

    def save_settings_data(self, name, data, timeout=0):
        current_time = Time()
        data = dict(time_ts=current_time.timestamp(), timeout=timeout, value=data)
        ret = SaveData(scope=DataScope.EA_SETTIGNS, name=name, data=data)
        return data

    def delete_settings_data(self, name):
        return DeleteData(scope=DataScope.EA_SETTIGNS, name=name)

    def load_group_data(self, name, default=None):
        cache_name = f"_group_data_{Symbol()}"
        data = self.load_settings_data(cache_name, dict(data={}))
        return data['data'].get(name, default)

    def save_group_data(self, name, value):
        cache_name = f"_group_data_{Symbol()}"
        data = self.load_settings_data(cache_name, dict(data={}))
        data['data'][name] = value
        return self.save_settings_data(cache_name, data)

    def clean_group_data(self):
        cache_name = f"_group_data_{Symbol()}"
        data = self.load_settings_data(cache_name, None)
        if data is not None:
            return self.delete_settings_data(cache_name)
        return True

    def process_group_trailing_profit(self, order, group_info, params):
        if not order.is_market():
            return False
        if order.status == OrderStatus.CLOSED:
            return False
        trailing_profit = order.tags.get('trailing_profit', None)
        if trailing_profit is not None:
            start_pips = trailing_profit['start_pips']
            step_pips = trailing_profit['step_pips']
            target_profit = trailing_profit['target_profit']
            processed = self.process_order_trailing_profit(order, dict(group_info=group_info, start_pips=start_pips,
                                                                       step_pips=step_pips,
                                                                       target_profit=target_profit
                                                                  ))
            if processed:
                return True
        current_time = Time()
        order_init = order.tags.get('init', None)
        if order_init is not None:
            seconds = 180
            init_ts = order_init.get('ts', 0)
            total_seconds = (current_time - order.open_time).total_seconds()
            if total_seconds > seconds and init_ts > 0:
                total_seconds = current_time.timestamp() - init_ts
            if total_seconds <= seconds:
                max_sl_pips = order_init.get('max_sl_pips', None)
                processed = self.process_order_init(order, dict(group_info=group_info,
                                                                max_sl_pips=max_sl_pips,
                                                                ))
                if processed:
                    return True

        return False

    def process_orders(self, params):
        group_info = self.get_group_info()
        if group_info is None:
            return False
        ho_dict = {}
        for oid in group_info['orders']:
            o = GetOrder(oid)
            if o.is_market():
                if o.status != OrderStatus.CLOSED:
                    ho_dict[oid] = o.open_time.timestamp()
        sorted_hedging_orders = [k for k, v in sorted(ho_dict.items(), key=lambda x: x[1], reverse=False)]
        close_uids = []
        d = Time()
        current_time_ts = d.timestamp()
        order_count = len(sorted_hedging_orders) - 1
        min_profit = 1
        close_reason = 'CLOSE_PREV'
        NIGHT_HOLDING = 'NIGHT_HOLDING'
        WEEKEND_HOLDING = 'WEEKEND_HOLDING'
        if close_reason not in (NIGHT_HOLDING, WEEKEND_HOLDING):
            if not OPTIONS_ENABLE_NIGHT_HOLDING and self.is_night(d):
                close_reason = NIGHT_HOLDING

        if close_reason not in (NIGHT_HOLDING, WEEKEND_HOLDING):
            if not OPTIONS_ENABLE_WEEKEND_HOLDING and self.is_weekend(d):
                close_reason = WEEKEND_HOLDING

        if close_reason in (NIGHT_HOLDING, WEEKEND_HOLDING):
            if d.hour >= 20:
                order_count = len(sorted_hedging_orders)
                min_profit = 0
                if d.hour >= 23:
                    min_profit = None

        for i in range(order_count):
            oid = sorted_hedging_orders[i]
            o = GetOrder(oid)
            if o.is_dirty:
                continue
            append = False
            if min_profit is None:
                append = True
            elif o.profit >= min_profit:
                append = True
            if append:
                close_uids.append(oid)
        if len(close_uids) > 0:
            self.runner.debug_print(f"WARNING: Close orders. (Reason: {close_reason}, min_profit={min_profit})",
                                    notify=False)
            errid, ret = CloseMultiOrders(close_uids)
            if errid == EID_OK:
                return True
        processed = False
        for oid in group_info['orders']:
            o = GetOrder(oid)
            if self.process_group_trailing_profit(o, group_info, params):
                processed = True

        return processed

    def was_order_updated(self, opened_order_dict, group_info):
        for oid in group_info['opened_orders']:
            if oid not in opened_order_dict:
                return True
        for oid in opened_order_dict:
            o = GetOrder(oid)
            if o.symbol == Symbol():
                if oid not in group_info['opened_orders']:
                    return True
        return False

    def trade_data_need_updated(self, opened_order_dict, group_info):
        next_cmds = self.get_order_commands(opened_order_dict, group_info)
        can_buy = OrderCommand.BUY in next_cmds
        can_sell = OrderCommand.SELL in next_cmds
        if can_buy and OrderCommand.BUY not in group_info['next']:
            return True
        if not can_buy and OrderCommand.BUY in group_info['next']:
            return True
        if can_sell and OrderCommand.SELL not in group_info['next']:
            return True
        if not can_sell and OrderCommand.SELL in group_info['next']:
            return True
        if OrderCommand.BUY in group_info['next']:
            if group_info['next'][OrderCommand.BUY]['td_uid'] != group_info['trade_data']['uid']:
                return True
        if OrderCommand.SELL in group_info['next']:
            if group_info['next'][OrderCommand.SELL]['td_uid'] != group_info['trade_data']['uid']:
                return True
        next_trade_data_config = self.load_group_data('next_trade_data_config', {})
        if next_trade_data_config is not None:
            source_id = next_trade_data_config.get('source_id', None)
            if source_id is not None:
                return True
        if not OPTIONS_ENABLE_GROUP_ACROSS_DAYS:
            current_time = Time()
            group_init_time = datetime.fromtimestamp(group_info['init']['ts'])
            if group_init_time.date() != current_time.date():
                return True

        return False

    def get_today_stats(self, item, group_info):
        stats = self.load_stats(stats_name='days')
        if stats is None:
            return 0
        date = Time().strftime("%Y-%m-%d")
        date_data = stats['data'].get(date, {})
        ret = 0
        stats = group_info.get('stats', {})
        if item == 'loss':
            ret = stats.get('closed_loss', 0) + date_data.get('total_loss', 0)
        elif item == 'profit':
            ret = stats.get('closed_profit', 0) + date_data.get('total_profit', 0)
        elif item == 'net_profit':
            ret = stats.get('closed_net_profit', 0) + date_data.get('total_net_profit', 0)
        return ret

    def make_trade_data_dict(
        self,
        open_price=0,
        init_size=0,
        stop_loss=0,
        take_profit=0,
        init_tp_pips=0,
        init_tp_money=0,
        init_sl_pips=0,
        init_sl_money=0,
        tp_pips=0,
        sl_pips=0,
    ):
        ret = dict(
            price=open_price,
            take_profit=take_profit,
            stop_loss=stop_loss,
            init_size=init_size,
            init_tp_pips=init_tp_pips,
            init_tp_money=init_tp_money,
            init_sl_pips=init_sl_pips,
            init_sl_money=init_sl_money,
            tp_pips=tp_pips,
            sl_pips=sl_pips,
        )
        return ret

    def calculate_tp_sl_pips(self, config, base_pips, order_size, balance):
        pips = None
        money = None
        if config is None:
            pips = 0
        elif isinstance(config, dict):
            config_type = config["type"]
            if config_type == "pips":
                pips = config["pips"]
            elif config_type == "money":
                money = float(config["money"])
                pips = self.runner.money_to_pips(abs(money), order_size)
            elif config_type == "percent":
                percent, rt, rs = to_float(config["percent"], failed_value=0)
                percent_source = config["source"]
                if percent_source == "atr":
                    period = config["period"]
                    timeframe = config["timeframe"]
                    shift = config.get('shift', 0)
                    symbol_data = GetSymbolData(Symbol(), timeframe=timeframe, size=period+shift+1)
                    atr = iATR(symbol_data, timeperiod=period, shift=0)
                    if not isnull(atr):
                        points = float(atr * abs(percent))
                        pips = self.runner.points_to_pips(points)
                else:
                    money = float(balance * abs(percent))
                    pips = self.runner.money_to_pips(money, order_size)
            elif config_type == "pl-ratio":
                ratio = float(config["ratio"])
                if ratio > 0:
                    pips = base_pips * ratio
        return dict(pips=pips, money=money)

    def calculate_order_data(self, order_config, balance):
        order_size = None
        tp_pips = 0
        sl_pips = 0
        cal_list = []
        positions = order_config.get("positions", None)
        martingale = None
        if isinstance(positions, dict):
            pos_type = positions["type"]
            if pos_type == "volume":
                order_size = float(positions["volume"])
            martingale = positions.get('martingale', None)
            if martingale is not None:
                if isinstance(martingale, bool) and martingale:
                    martingale  = dict(multiplier=0)
        #
        tp_config = order_config.get("take_profit", None)
        sl_config = order_config.get("stop_loss", None)
        #
        result = dict(tp={'pips': None}, sl={'pips': None})
        if tp_config and tp_config['type'] == 'pl-ratio':
            cal_list.append(dict(name='sl', config=sl_config, base_pip_name='tp'))
            cal_list.append(dict(name='tp', config=tp_config, base_pip_name='sl'))
        else:
            cal_list.append(dict(name='tp', config=tp_config, base_pip_name='sl'))
            cal_list.append(dict(name='sl', config=sl_config, base_pip_name='tp'))
        #
        for cal in cal_list:
            base_pips = result[cal['base_pip_name']]['pips']
            data = self.calculate_tp_sl_pips(cal['config'], base_pips, order_size, balance)
            if data['pips'] is None:
                return None
            result[cal['name']] = data

        #calculate order size
        pos_money = None
        if pos_type == 'money':
            pos_money = float(positions["money"])
        elif pos_type == "percent":
            percent, rt, rs = to_float(positions["percent"], failed_value=0)
            pos_money = float(balance * percent)
        if pos_money is not None:
            if pos_money > 0:
                order_size = self.runner.money_to_lots(pos_money, result['tp']['pips'])
            elif pos_money < 0:
                order_size = self.runner.money_to_lots(abs(pos_money), result['sl']['pips'])

        #
        return dict(order_size=order_size, martingale=martingale,
                    take_profit=dict(pips=result['tp']['pips'], money=result['tp']['money'], points=self.runner.pips_to_points(result['tp']['pips'])),
                    stop_loss=dict(pips=result['sl']['pips'], money=result['sl']['money'], points=self.runner.pips_to_points(result['sl']['pips'])))

    def calculate_trade_size(self, order_data, fees, net_profit):
        tp_pips = order_data['take_profit']['pips']
        sl_pips = order_data['stop_loss']['pips']

        ep_size = 0
        fees_size = 0
        if fees < 0:
            fees_size = self.runner.money_to_lots(abs(fees), tp_pips)
        group_init_order_size = order_data['order_size']
        base_lots = group_init_order_size
        multiplier = 0
        martingale = order_data.get('martingale', None)
        if martingale:
            multiplier = float(martingale.get('multiplier', 0))
            if multiplier <= 0:
                tp_sl_ratio = tp_pips / sl_pips
                multi = 1 / tp_sl_ratio
                multiplier = 1 + multi
        target_profit = self.runner.lots_to_money(base_lots, tp_pips)
        loss_amount = net_profit
        if loss_amount < 0 and multiplier > 0:
            l_lots = self.runner.money_to_lots(abs(loss_amount), tp_pips) * multiplier
            target_profit = target_profit + abs(loss_amount)
            l_min_lots = self.runner.money_to_lots(target_profit, tp_pips)
            base_lots = max(l_min_lots, l_lots)
        base_size = base_lots + ep_size + fees_size
        return base_size, target_profit

    def calculate_signal_range(self, symbol, balance):
        entry_data = self.get_entry_data()
        if len(entry_data) == 0:
            return None
        timeframe = TimeFrame.H1
        sd_h1 = GetSymbolData(symbol, timeframe=timeframe, size=100)
        if sd_h1.time[1] is None:
            return None

        orders = 0
        ed = entry_data.get(PositionType.SHORT, None)
        if ed is None:
            sell_info = None
        else:
            sell_price = ed.get("price", None)
            if sell_price is None:
                sell_price = Ask()
            sell_info = self.make_trade_data_dict(
                open_price=sell_price,
            )
        ed = entry_data.get(PositionType.LONG, None)
        if ed is None:
            buy_info = None
        else:
            buy_price = ed.get("price", None)
            if buy_price is None:
                buy_price = Bid()
            buy_info = self.make_trade_data_dict(
                open_price=buy_price,
            )


        current_time_ts = Time().timestamp()
        ret = {
            "uid": str(int(current_time_ts)),
            "time": sd_h1.time[0],
            "timestamp": sd_h1.time[0].timestamp(),
            OrderCommand.BUY: buy_info,
            OrderCommand.SELL: sell_info,
        }

        return ret

    def make_trade_data(self, td_uid,  buy_info, sell_info, timestamp, source='signal', source_id='',
                        timeout=None):
        ret = {'uid': td_uid,
               OrderCommand.BUY: buy_info, OrderCommand.SELL: sell_info,
               'time': str(datetime.fromtimestamp(timestamp)),
               'ts': timestamp, 'source': source, 'source_id': source_id}
        if timeout:
            ret['timeout'] = timeout
        return ret

    def generate_group_info(self, symbol, current_time):
        account = GetAccount()
        balance = account.balance
        signal_range = self.calculate_signal_range(symbol, balance)
        if signal_range is None:
            return None

        td_uid = signal_range['uid']
        buy_info = signal_range[OrderCommand.BUY]
        sell_info = signal_range[OrderCommand.SELL]
        timestamp = signal_range['timestamp']
        signal_info = signal_range.get('signal_info', None)
        timeout = signal_range.get('timeout', None)
        ext_data = signal_range.get('ext_data', None)

        group_info = dict(
                          orders={},
                          sorted_orders=[],
                          opened_orders={},
                          group_id=int(current_time.timestamp()),
                          trade_data=self.make_trade_data(td_uid,  buy_info, sell_info, timestamp,
                                                          timeout=timeout),
                          trade_units={},
                          config={},
                          init={'equity': account.equity, 'balance': balance, 'symbol': symbol,
                                'ts': timestamp}
                          )
        return group_info


    def get_group_finished_reason(self, symbol, current_time, group_info, symbol_orders):
        trade_data = group_info['trade_data']
        if len(group_info['opened_orders']) == 0:
            if not OPTIONS_ENABLE_GROUP_ACROSS_DAYS:
                group_init_time = datetime.fromtimestamp(group_info['init']['ts'])
                if group_init_time.date() != current_time.date():
                    reason = 'GROUP_ACROSS_DAYS'
                    message = f"{str(group_init_time)} != {str(current_time)}"
                    return reason, message
        if len(group_info['orders']) > 0:
            if len(group_info['opened_orders']) == 0:
                closed_net_profit = symbol_orders['closed_net_profit']
                if closed_net_profit >= 0:
                    reason = 'GOT_PROFIT'
                    message = f"{symbol_orders['closed_net_profit']} >= 0"
                    return reason, message
                else:
                    sd_h1 = GetSymbolData(symbol, timeframe=TimeFrame.H1, size=10)
                    valid_range = trade_data.get('valid_range', None)
                    if valid_range is not None:
                        if not self.is_price_in_range(sd_h1.close[1], valid_range) \
                                and not self.is_price_in_range(sd_h1.close[2], valid_range):
                            reason = 'INVALID_PRICE_RANGE'
                            message = f"{sd_h1.close[1]}, {sd_h1.close[2]}"
                            return reason, message
        else:
            td_timeout = trade_data.get('timeout', None)
            if not td_timeout:
                td_timeout = CACHE_EXPIRE_S
            price_time = datetime.fromtimestamp(trade_data['ts'])
            total_seconds = (current_time - price_time).total_seconds()
            if total_seconds > td_timeout:
                reason = 'TIMEOUT'
                message = f"{total_seconds} > {CACHE_EXPIRE_S}"
                return reason, message

        return None, None

    def is_group_finished(self, symbol, current_time, group_info, symbol_orders):
        reason, message = self.get_group_finished_reason(symbol, current_time, group_info, symbol_orders)
        if reason is not None:
            info = f"INFO: The group (group_id={group_info['group_id']}) was finished ({reason}, {message} )."
            self.runner.debug_print(info, notify=False)
            group_info['status'] = dict(status='finished', reason=reason, time=str(current_time))
            return True
        return False

    def group_end(self, group_info):
        self.runner.debug_print(
            f"WARNING: group_end: The group was end {group_info}",
            notify=False)
        cache_name = f"open_info_{Symbol()}"
        if len(group_info['orders']) > 0:
            temp_data = group_info.copy()
            trade_data_dict = self.load_group_data('trade_data', {})
            temp_data['trade_data_records'] = trade_data_dict
            self.save_group_logs(group_info)
        DeleteData(scope=DataScope.EA_SETTIGNS, name=cache_name)
        self.clean_group_data()

    def get_order_commands(self, opened_order_dict, group_info):
        next_cmds = [OrderCommand.BUY, OrderCommand.SELL]
        td = group_info['trade_data']
        if td.get(OrderCommand.BUY, None) is None:
            next_cmds.remove(OrderCommand.BUY)
        if td.get(OrderCommand.SELL, None) is None:
            next_cmds.remove(OrderCommand.SELL)
        for oid in opened_order_dict:
            o = GetOrder(oid)
            if o.symbol == Symbol():
                if o.is_long() and OrderCommand.BUY in next_cmds:
                    next_cmds.remove(OrderCommand.BUY)
                elif OrderCommand.SELL in next_cmds:
                    next_cmds.remove(OrderCommand.SELL)

        return next_cmds


    def stats_group_orders(self, opened_order_dict, group_info):
        symbol_orders = {
            OrderCommand.BUY: {'count': 0, 'size': 0, 'tp_points': 0, 'sl_points': 0, 'cl_points': 0, 'uids': []},
            OrderCommand.SELL: {'count': 0, 'size': 0, 'tp_points': 0, 'sl_points': 0, 'cl_points': 0, 'uids': []},
            'count': 0, 'profit_count': 0, 'commission': 0.0, 'swap': 0.0, 'profit': 0.0, 'loss': 0.0, 'net_profit': 0.0,
            'closed_uids': [], 'closed_volume': 0, 'closed_profit': 0.0, 'closed_loss': 0.0,
            'closed_net_profit': 0.0, 'closed_swap': 0.0, 'closed_commission': 0.0,
        }
        for oid in opened_order_dict:
            o = GetOrder(oid)
            if o.is_dirty:
                return None
            if o is None:
                continue
            if o.symbol == Symbol() and oid not in group_info['orders']:
                group_info['orders'][oid] = {}
                group_info['sorted_orders'].append(oid)
                group_info['opened_orders'][oid] = {}
                td_uid = o.tags['init']['td_uid']
                td_unit = group_info['trade_units'].get(td_uid, {'orders': [],
                                                                 OrderCommand.BUY: {'count': 0, 'size': 0,},
                                                                 OrderCommand.SELL: {'count': 0, 'size': 0,},
                                                                 })
                td_unit['orders'].append(oid)
                if o.is_long():
                    order_cmd = OrderCommand.BUY
                else:
                    order_cmd = OrderCommand.SELL
                td_unit[order_cmd]['count'] = td_unit[order_cmd]['count'] + 1
                td_unit[order_cmd]['size'] = td_unit[order_cmd]['size'] + o.volume
                group_info['trade_units'][td_uid] = td_unit
        for oid in group_info['orders']:
            o = GetOrder(oid)
            if o.is_market():
                symbol_orders['count'] = symbol_orders['count'] + 1
                if o.profit >= 0:
                    symbol_orders['profit'] = symbol_orders['profit'] + o.profit
                else:
                    symbol_orders['loss'] = symbol_orders['loss'] + o.profit
                symbol_orders['commission'] = symbol_orders['commission'] + o.commission
                symbol_orders['swap'] = symbol_orders['swap'] + o.swap
                symbol_orders['net_profit'] = symbol_orders['profit'] + symbol_orders['loss'] + symbol_orders['commission'] + symbol_orders['swap']
                symbol_orders[o.cmd]['size'] = symbol_orders[o.cmd]['size'] + o.volume
                symbol_orders[o.cmd]['count'] = symbol_orders[o.cmd]['count'] + 1
                symbol_orders[o.cmd]['uids'].append(oid)
                if o.status == OrderStatus.CLOSED:
                    symbol_orders['closed_uids'].append(oid)
                    symbol_orders['closed_volume'] = symbol_orders['closed_volume'] + o.volume
                    if o.profit >= 0:
                        symbol_orders['closed_profit'] = symbol_orders['closed_profit'] + o.profit
                    else:
                        symbol_orders['closed_loss'] = symbol_orders['closed_loss'] + o.profit
                    symbol_orders['closed_swap'] = symbol_orders['closed_swap'] + o.swap
                    symbol_orders['closed_commission'] = symbol_orders['closed_commission'] + o.commission
                    symbol_orders['closed_net_profit'] = symbol_orders['closed_profit'] + \
                                                         symbol_orders['closed_loss'] + \
                                                         symbol_orders['closed_commission'] + \
                                                         symbol_orders['closed_swap']
                    if o.profit > 0:
                        symbol_orders['profit_count'] = symbol_orders['profit_count'] + 1
                    group_info['opened_orders'].pop(oid, None)
                    if o.is_long():
                        symbol_orders[o.cmd]['cl_points'] = symbol_orders[o.cmd]['cl_points'] + (
                                (o.close_price - o.open_price) * o.volume)
                    else:
                        symbol_orders[o.cmd]['cl_points'] = symbol_orders[o.cmd]['cl_points'] + (
                                (o.open_price - o.close_price) * o.volume)
                    if symbol_orders[o.cmd]['cl_points'] > 0:
                        symbol_orders[o.cmd]['tp_points'] = symbol_orders[o.cmd]['tp_points'] + symbol_orders[o.cmd][
                            'cl_points']
                    else:
                        symbol_orders[o.cmd]['sl_points'] = symbol_orders[o.cmd]['sl_points'] + abs(
                            symbol_orders[o.cmd]['cl_points'])

                else:
                    symbol_orders[o.cmd]['tp_points'] = symbol_orders[o.cmd]['tp_points'] + (
                            abs(o.take_profit - o.open_price) * o.volume)
                    symbol_orders[o.cmd]['sl_points'] = symbol_orders[o.cmd]['sl_points'] + (
                            abs(o.stop_loss - o.open_price) * o.volume)
        return symbol_orders

    def get_group_info(self, symbol=Symbol(), cache_expire_s=CACHE_EXPIRE_S):
        cache_name = f"open_info_{symbol}"
        current_time = Time()
        opened_order_list = GetOpenedOrderUIDs(scope=DataScope.EA_VERSION)
        new_group = False
        data = LoadData(scope=DataScope.EA_SETTIGNS, name=cache_name)
        if data is not None:
            group_info = data['value']
            expire_s = float(data.get('expire_s', cache_expire_s))
            data_time = datetime.fromtimestamp(data['time_ts'])
            total_seconds = (current_time - data_time).total_seconds()
            if total_seconds < expire_s:
                updated = False
                if not updated \
                    and self.was_order_updated(opened_order_list, group_info):
                        updated = True
                if not updated \
                    and self.trade_data_need_updated(opened_order_list, group_info):
                        updated = True
                if not updated:
                    return group_info
        if data is None:
            if GROUP_COLD_DOWN_MINUTE > 0:
                stats_name = f"stats_{Symbol()}"
                stats = self.load_settings_data(stats_name, None)
                if stats is not None:
                    last_group_end_time = datetime.fromtimestamp(stats['last_group_end_time_ts'])
                    total_seconds = (current_time - last_group_end_time).total_seconds()
                    if total_seconds < GROUP_COLD_DOWN_MINUTE * 60:
                        self.runner.debug_print(
                            f"WARNING: During group cold down ({total_seconds} < {GROUP_COLD_DOWN_MINUTE * 60} sec), "
                            f"New group was disabled.",
                            notify=False)
                        return None
            group_info = self.generate_group_info(symbol, current_time)
            if group_info is None:
                return None
            data = dict(time_ts=current_time.timestamp(), value=group_info)
            self.runner.debug_print(
                f"get_group_info: Generate new group info: {Symbol()}, {current_time}, ts={current_time.timestamp()}, {data}",
                notify=False)
            new_group = True
        group_info = data['value']
        symbol_orders = self.stats_group_orders(opened_order_list, group_info)
        if not new_group and self.is_group_finished(symbol, current_time, group_info, symbol_orders):
            group_info['stats'] = symbol_orders
            self.group_end(group_info)
            return None
        next_cmds = self.get_order_commands(opened_order_list, group_info)
        tags = dict(group_id=group_info['group_id'], sorted_orders=group_info['sorted_orders'], )

        trade_data = self.calculate_next_trade_data(group_info)
        tags['init'] = dict(td_uid=trade_data['uid'], td_source=trade_data['source'],
                            td_source_id=trade_data['source_id'])
        tags['order_index'] = symbol_orders['count']
        offset_stop_loss_points = 0
        fees = symbol_orders['commission'] + symbol_orders['swap']
        min_lot = SymbolInfo("volume_min")
        net_profit = symbol_orders['net_profit']
        next = {}
        next_offset_pips  = 0
        if OrderCommand.SELL in next_cmds:
            self.make_next_trade_command(group_info, next, OrderCommand.SELL, tags, trade_data, symbol_orders, fees,
                                         net_profit, min_lot, next_offset_pips, offset_stop_loss_points)
        if OrderCommand.BUY in next_cmds:
            self.make_next_trade_command(group_info, next, OrderCommand.BUY, tags, trade_data, symbol_orders, fees,
                                         net_profit, min_lot, next_offset_pips, offset_stop_loss_points)
        group_info['trade_data'] = trade_data
        group_info['next'] = next
        group_info['stats'] = symbol_orders
        data['time_ts'] = current_time.timestamp()

        self.runner.debug_print(
            f"get_group_info: Save data: {Symbol()}, {current_time}, ts={current_time.timestamp()}, {data}",
            notify=False)
        self.save_group_info(group_info=group_info, symbol=symbol)
        return data['value']

    def save_group_info(self, group_info, symbol=Symbol()):
        cache_name = f"open_info_{symbol}"
        data = dict(time_ts=Time().timestamp(), value=group_info)
        ret = SaveData(scope=DataScope.EA_SETTIGNS, name=cache_name, data=data)
        return ret

    def calculate_next_trade_data(self, group_info):
        return group_info['trade_data']

    def get_trailing_profit(self, tp_pips, target_profit):
        trailing_step_pips = tp_pips * 0.1
        trailing_profit = dict(start_pips=tp_pips + trailing_step_pips, step_pips=trailing_step_pips,
                               target_profit=target_profit)
        return trailing_profit

    def make_next_trade_command(self, group_info, next, cmd, tags, trade_data, symbol_orders, fees, net_profit, min_lot,
                                    next_offset_pips, offset_stop_loss_points):
        trade_info = trade_data[cmd]
        if trade_info is None:
            return next
        #
        if cmd == OrderCommand.BUY:
            order_config = dict(
                                positions=load_json_value(ENTRY_LONG_POSITIONS),
                                take_profit=load_json_value(ENTRY_LONG_TAKE_PROFIT),
                                stop_loss=load_json_value(ENTRY_LONG_STOP_LOSS))
        else:
            order_config = dict(
                                positions=load_json_value(ENTRY_SHORT_POSITIONS),
                                take_profit=load_json_value(ENTRY_SHORT_TAKE_PROFIT),
                                stop_loss=load_json_value(ENTRY_SHORT_STOP_LOSS))
        order_data = self.calculate_order_data(order_config, group_info['init']['balance'])

        base_size, target_profit = self.calculate_trade_size(order_data, fees, net_profit)
        if base_size is None:
            return next
        size = base_size
        size = round(size, MAX_POINTS)
        if size <= symbol_orders[OrderCommand.BUY if cmd == OrderCommand.SELL else OrderCommand.SELL]['size']:
            size = size + min_lot
        size = int((size + (min_lot * 0.99)) / min_lot) * min_lot
        #
        open_price = trade_data[cmd]['price']
        tp_points = order_data['take_profit']['points']
        sl_points = order_data['stop_loss']['points']
        if tp_points > 0:
            take_profit = open_price - tp_points if cmd == OrderCommand.SELL else open_price + tp_points
        else:
            take_profit = None
        if sl_points > 0:
            stop_loss = open_price + sl_points - offset_stop_loss_points if cmd == OrderCommand.SELL else open_price - sl_points + offset_stop_loss_points
        else:
            stop_loss = None

        tags['init']['max_sl_pips'] = order_data['stop_loss']['pips']
        tags['trailing_profit'] = self.get_trailing_profit(order_data['take_profit']['pips'], target_profit)
        next[cmd] = dict(size=size, tags=tags, take_profit=take_profit,
                         stop_loss=stop_loss, td_uid=trade_data['uid'])
        return next


    def open_new(self, new_order_list, params):
        trading_info = self.get_group_info()
        if trading_info is None:
            return False
        ret = self.open_next(trading_info, new_order_list, params)
        if ret:
            return True
        return False

    def open_next(self, trading_info, new_order_list, params):
        stats_info = trading_info['stats']
        if RISK_DAY_MAX_LOSS < 0:
            today_loss = self.get_today_stats('loss', trading_info)
            if RISK_DAY_MAX_LOSS >= today_loss:
                self.runner.debug_print(f"open_next: RISK_DAY_MAX_LOSS limit. ({RISK_DAY_MAX_LOSS} >= {today_loss})")
                return False

        if RISK_DAY_MAX_PROFIT > 0:
            today_profit = self.get_today_stats('profit', trading_info)
            if RISK_DAY_MAX_PROFIT <= today_profit:
                self.runner.debug_print(f"open_next: RISK_DAY_MAX_PROFIT limit. ({RISK_DAY_MAX_PROFIT} <= {today_profit})")
                return False

        group_max_orders = trading_info.get('group_max_orders', 0)
        if group_max_orders > 0:
            group_orders = len(trading_info['sorted_orders'])
            if group_orders >= group_max_orders:
                self.runner.debug_print(f"open_next: GROUP_MAX_ORDERS limit. ({group_orders} >= {group_max_orders})")
                return False

        spread_points = abs(Ask() - Bid()) * 0.25
        trade_data = trading_info['trade_data']
        buy_info = trading_info['next'].get(OrderCommand.BUY, None)
        sell_info = trading_info['next'].get(OrderCommand.SELL, None)
        can_open = False
        open_reason = tags = position = None

        price = take_profit = stop_loss = size = 0
        open_direction = GROUP_OPEN_DIRECTION
        if open_direction in (OD_DISABLE, OD_SHORT_ONLY):
            self.runner.debug_print(f"open_next: Disable long. (GROUP_OPEN_DIRECTION={GROUP_OPEN_DIRECTION})")
        elif not can_open and buy_info:
            last_ask = Ask(1)
            ask = Ask()
            offset_points = buy_info.get('offset_points', 0)
            min_price = trade_data[OrderCommand.BUY]['price'] + offset_points
            max_price = trade_data[OrderCommand.BUY].get('max_price', trade_data[OrderCommand.BUY]['price']) + offset_points
            open_order = False
            if Open() <= min_price and max_price > ask >= min_price - spread_points:
                open_order = True
                open_reason = 'OPEN_PRICE'
            if not open_order:
                if OPTIONS_ENABLE_OPEN_CROSSING and ask > max_price:
                    if Low() <= min_price - spread_points:
                        open_order = True
                        open_reason = 'OPEN_CROSSING'

            if open_order:
                position = PositionType.LONG
                if ask < min_price:
                    price = min_price
                else:
                    price = ask
                size = buy_info['size']
                tags = buy_info['tags']
                take_profit = buy_info['take_profit']
                stop_loss = buy_info['stop_loss']
                can_open = True
        if open_direction in (OD_DISABLE, OD_LONG_ONLY):
            self.runner.debug_print(f"open_next: Disable short. (GROUP_OPEN_DIRECTION={GROUP_OPEN_DIRECTION})")
        elif not can_open and sell_info:
            last_bid = Bid(1)
            bid = Bid()
            offset_points = sell_info.get('offset_points', 0)
            min_price = trade_data[OrderCommand.SELL].get('min_price', trade_data[OrderCommand.SELL]['price']) - offset_points
            max_price = trade_data[OrderCommand.SELL]['price'] - offset_points
            open_order = False
            if Open() >= max_price and min_price < bid <= max_price + spread_points:
                open_order = True
                open_reason = 'OPEN_PRICE'
            if not open_order:
                if OPTIONS_ENABLE_OPEN_CROSSING and bid < min_price:
                    if High() >= max_price + spread_points:
                        open_order = True
                        open_reason = 'OPEN_CROSSING'
            if open_order:
                position = PositionType.SHORT
                if bid > max_price:
                    price = max_price
                else:
                    price = bid
                size = sell_info['size']
                tags = sell_info['tags']
                take_profit = sell_info['take_profit']
                stop_loss = sell_info['stop_loss']
                can_open = True
        current_time = Time()
        if can_open:
            if size > RISK_GROUP_MAX_ORDER_SIZE > 0:
                self.runner.debug_print(f"WARNING: Exceed RISK_GROUP_MAX_ORDER_SIZE. ({size} >= {RISK_GROUP_MAX_ORDER_SIZE})")
                return False

            new_order_dict = {}
            new_order_dict['errid'] = 0
            new_order_dict['position'] = position
            new_order_dict['price'] = price
            new_order_dict['take_profit'] = take_profit
            new_order_dict['stop_loss'] = stop_loss
            new_order_dict['size'] = size
            new_order_dict['tags'] = tags
            new_order_list.append(new_order_dict)
            self.runner.debug_print(f"WARNING: Open order. (Reason: {open_reason}, new_order_dict={new_order_dict})",
                                    notify=False)

        return can_open


    def get_entry_data(self):
        {%  for code in strategy['code']['get_entry_data']  -%}
        {{ code }}
        {% endfor %}

    def get_exit_data(self):
        {%  for code in strategy['code']['get_exit_data']  -%}
        {{ code }}
        {% endfor %}

    {{ strategy['code'].get('class', '') }}

{% endif %}